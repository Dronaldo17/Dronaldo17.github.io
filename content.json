[{"title":"初探Weex iOS篇(一)","date":"2017-07-17T14:17:51.000Z","path":"2017/07/17/weex-iOS/","text":"iOS准备阶段 要在iOS端”玩起” Weex,至少要知道或者熟悉以下知识: 1.首先要清楚一件事情就是,Weex的UI是原生控件,并不是纯WebView，不是Hybrid方案! 2.其次得有相应的iOS开发知识,知道从前有一门叫 SmtallTalk,现在叫做Objective-C简称OC的编程语言(Swift也可以编写iOS程序,但是鉴于Weex代码是Objective-C版本,且项目中我们大量使用了runtime的特性,目前我们只讨论OC版) 3.知道iOS7 之后 Apple提供了一个叫 JavaScriptCore 的库。JavaScriptCore是Webkit的一个重要组成部分，主要是对JS进行解析和提供执行环境。极大的方便了我们对js的操作。我们可以脱离Webview直接运行我们的js。这也是 Weex,React Native,JSPatch这些框架能流行起来的重要原因。 剑神一笑 江湖有云: 武林至尊,宝刀屠龙，号令天下，莫敢不从。倚天不出，谁与争锋。 有个JavaScriptCore这把屠龙刀, 怎能没有倚天剑？这把倚天剑便是runtime,BM-Weex在iOS端无论在功能拓展性和代码结构的解耦上,都大量用到了这把”倚天剑”。 以前我们在开发iOS项目时,如果需要引用一些大的框架，如Facebook早期的Three20,他是自带了一个Python脚本。我们有新的定制化需求时,不能满足,早期的我们可能直接在其源码上做了修改。这样就局限了引用第三方版本的升级和Bug的官方修复,后来我们可以添加类别,类目等方式去实现需求,但是当不可避免修改源码时,问题又回到了开始的地方,其实可以利用OC的”动态语言”的特性，利用AOP的思想去实现方法前，后插入自定义代码或者直接进行“方法替换”,替换任何开源代码的实现。 BM-Weex对Weex的二次封装 主要运用在项目的三个方面: 1.Weex 系统组件的功能拓展和Bug修复 2.Weex 网络层的请求拦截实现 js 和 iconfont 的预加载 3.Weex 自定义Module使用本地封装的功能 尽量做到Module的最小程度的修改和最大程度的复用 如果你已经有几年的iOS的Native开发经验，那么Weex对于你来说主需要了解它的思想即可，因为你可以用runtime进行大量“有趣”的尝试，就像是一个武林高手，例如西门吹雪用了倚天剑，效果你可以自己想象一下哈~ iOS上帝视角解读WeexWeex 在iOS端主要分为几个重要的模块 例如WXSDKEngine, WXSDKInstance, WXBridgeManager, WXComponent, WXModuleProtocol等，下面解读一下: 1.WXSDKEngine 主要用于初始化WeexSDK的环境,加载Weex内置main.js文件以及Weex官方提供的Component,Module,Handler。2.WXSDKInstance 一个 WXSDKInstance 对应一个Weex页面,如果是SPA应用,就对应一个ViewController,但是我们的大部分场景应该不是SPA,所以基本在Weex项目中，一个 WXSDKInstance 对应一个ViewController。3.WXBridgeManager,WXBridgeContext,WXJSCoreBridge是JS与iOS进行交互的,所有JS与Native的交互都在这三个类的各层封装中。4.WXComponent 组件基类，所以跟UI相关的，我们都得自己实现iOS端的组件，都必须继承于 WXComponent5.WXImgLoaderProtocol WeexSDK 默认没有实现图片加载，需要自己实WXImgLoaderProtocol协议,于此类似的还有networkprotocol,这样大大方便了开发者去自实现一些功能。 UI Component JS-OC 通信 自定义Module WXImageComponent，WXTextComponent等 WXBridgeContext,WXJSCoreBridge等 WXDomModule等 实践自定义Component,Module1.安装iOS开发环境 及 CocoaPods，并集成WeexSDK到项目中。 iOS开发环境 及 CocoaPods 安装方式请查询官方文这里就不再赘述了； WeexSDK 我们采用的是源码集成，也推荐大家采用源码的集成方式，一方面是因为 Weex 目前还处于初期 Beta 阶段，官方文档不完善，通过阅读源码可以更加深入的了解学习 Weex 的功能及底层实现原理；另一方面 Weex 本身也存在一些 bug 便于快速定位问题，方便在原有功能组件基础上进行定制化开发； 12345/* 源码集成方式 首先 拷贝 SDK 目录到你项目的根目录，然后在 Podfile 文件中添加*/pod &apos;WeexSDK&apos;, :path=&gt;&apos;./sdk/&apos; 2.集成 WXDevtool 调试 SDK。 WXDevtool也是官方提供的 SDK，结合 weex-toolkit脚手架工具，能够帮助你快速查看 app 运行状态和调试 Weex 中的 JS 代码；相信大家都使用过官方的 Playground App调试过 Weex 页面，为了方便调试项目，我们需要将 ‘扫一扫调试’ 功能集成到自己的项目中，客户端需要做的就是集成 WXDevtool,然后参照Playground App中的 WXScannerVC的实现，或者直接将 WXScannerVC 移植到自己的项目中。 12// Podfilepod &apos;WXDevtool&apos; Module扩展官方已经为我们提供了一些內建模块，如：stream（提供网络请求）、navigator（页面导航及定义NavigationBar)、modal（提示框，Alert弹窗）等 module，在实际开发中需求是层出不穷的，使用內建module不足以支撑我们的需求，最好的做法就是我们根据业务需求自定义 module 这样易维护也容易扩展；在Weex上扩展 module 也是非常的简单； 自定义 Module 的步骤1.自定义的module类 必须实现WXModuleProtocol。2.必须添加宏WX_EXPORT_METHOD, 它可以被Weex识别，它的参数是 JavaScript调用 module指定方法的参数。3.添加@synthesized weexInstance，每个moudle对象被绑定到一个指定的实例上。4.Module 方法会在UI线程中被调用，所以不要做太多耗时的任务在这里，如果要在其他线程执行整个module 方法，需要实现。WXModuleProtocol中- (NSThread *)targetExecuteThread的方法，这样，分发到这个module的任务会在指定的线程中运行。5.Weex 的参数可以是 String 或者Map。6.Module 支持返回值给 JavaScript中的回调，回调的类型是WXModuleCallback,回调的参数可以是String或者Map。 JS 与 Native 端通过 Module 交互极其方便，参数可以是String、Map，灵活性也很高，建议采取Map的方式传值（js端将参数以键值对的方式传给 native 端），这样可以简短方法命，而且易扩展； 例子：BMAxiosNetworkModule 是我们自己实现的网络请求模块 123456/* BMAxiosNetworkModule.h */// 实现 WXModuleProtocol 协议@interface BMAxiosNetworkModule : NSObject &lt;WXModuleProtocol, BMModuleProtocol&gt;@end 1234567891011121314151617181920212223242526272829303132333435363738394041/* BMAxiosNetworkModule.m */@implementation BMAxiosNetworkModule// 绑定 WXSDKInstance 实例@synthesize weexInstance;// 将方法暴露出去WX_EXPORT_METHOD(@selector(fetch:callback:)) /** js调用 网络请求方法 @param info 字典类型(map): &#123; method: &apos;GET&apos; // 请求类型 GET or POST url: &apos;&apos;, // 请求路径，前端自己拼好 host，发送完整请求 URL header: &#123;&#125;, // 请求 header noRepeat: true, // 请求是否允许重复，默认是 false，如果为 true，发现队列中有类似请求需要 cancel 掉 data: &#123;&#125; // 请求参数 &#125; @param callback 回调js方法，将请求的数据返回给js处理 */- (void)fetch:(NSDictionary *)info callback:(WXModuleCallback)callback&#123; // 解析请求信息 BMAxiosRequestModel *requestModel = [BMAxiosRequestModel yy_modelWithJSON:info]; // 根据业务需求 native 端处理一些请求 比如 拦截一些请求、统一添加一些参数 等 [BMAxiosFilter axiosFilterRequestModel:requestModel]; // BMCommonRequest 为 native 端实现的网络请求方法 BMCommonRequest *api = [[BMCommonRequest alloc] initWithRequestModel:requestModel]; // 发送请求 [api startRequestResult:^(id data) &#123; // 通过 callback 将处理好的请求数据回传给 js 端 if (callback) &#123; callback(data); &#125; &#125;];&#125; 12// 注册module[WXSDKEngine registerModule:@&quot;bmAxios&quot; withClass:[BMAxiosNetworkModule class]]; Component扩展官方已经为我们提供了常用的组件，这些组件目前可以支撑我们的App，我们在官方组件的基础上根据需求扩展了一些功能；比如我们有个需求，用户可以动态设置字体大小，（标准、大号、特大三种选择）。 方案1：Weex支持动态修改 styles，所以 js 端同学可以通过动态改变样式中的 fontSize 的值达到目的,但是使用Text标签的地方实在是太多了，而且后期一单需求变更 js 端同学估计得崩溃； 方案2：Native 端实现；（恩，看来也只能这样了）。 分析一下这个需求可以发现其实我们要解决两件事：1.Text控件初始化的时候要根据用户选择设置字体大小；2.已经存在的控件动态修改字体大小；针对第一个问题：我们只需要在 WXTextComponent 的初始化方法initWithRef:type:styles:attributes:events:weexInstance:中，将 styles 中的 fontSize 修改成我们需要放大的值（根据当前环境将css定义的默认字体大小修改）；第二个问题：在初始化方式中注册修改字体的通知，然后触发 _updateStylesOnComponentThread:resetStyles:isUpdateStyles: 方法来更新样式即可； 得益于 OC 强大的 runtime 机制,我们可以做到使用AOP的方式，在不修改源码的基础上修改 WXText 初始化方法；实现WXTextComponent的 category WXTextComponent+BMExtend： 12345678910// WXTextComponent+BMExtend.h#import &lt;WeexSDK/WeexSDK.h&gt;#import &lt;WeexSDK/WXTextComponent.h&gt;@interface WXTextComponent (BMExtend)// 定义交互方法- (instancetype)bmText_initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance;@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// WXTextComponent+BMExtend.m#import &quot;WXTextComponent+BMExtend.h&quot;#import &lt;WeexSDK/WXComponent_internal.h&gt;const void * _defaultFontSizeKey = &quot;bm_defaultFontSize&quot;;@implementation WXTextComponent (BMExtend)// 方法实现- (instancetype)bmText_initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; /* 注册修改字体通知 */ [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeFontSize) name:K_CHANGE_FONT_SIZE_NOTIFICATION object:nil]; /* 解析标准字体大小 */ NSMutableDictionary *dic4Styles = [NSMutableDictionary dictionaryWithDictionary:styles]; NSNumber *cssFontSize = dic4Styles[@&quot;fontSize&quot;]; CGFloat _defaultFontSize = [cssFontSize floatValue]; /* 将css 定义的标准字体保存为属性 */ objc_setAssociatedObject(self, _defaultFontSizeKey, [NSNumber numberWithFloat:_defaultFontSize], OBJC_ASSOCIATION_RETAIN_NONATOMIC); /* 根据当前用户设置的字体大小 获取将要放大的字体大小 */ CGFloat changeFontSize = [self getChangeToFontSizeWithDefaultSize:_defaultFontSize]; /* 修改styles中 fontSize 值为需要改变的字体大小 */ [dic4Styles setValue:[NSNumber numberWithFloat:changeFontSize] forKey:@&quot;fontSize&quot;]; styles = [NSDictionary dictionaryWithDictionary:dic4Styles]; /* 调用 WXTextComponent 的初始化方法 */ return [self bmText_initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance];&#125;/* 修改字体大小通知返回方法 */- (void)changeFontSize&#123; /* 获取之前保存的标准字体大小 */ NSNumber *defaultSize = objc_getAssociatedObject(self, _defaultFontSizeKey); if (!defaultSize) return; /* 根据当前用户设置的字体大小 获取将要放大的字体大小 */ CGFloat changeFontSize = [self getChangeToFontSizeWithDefaultSize:[defaultSize floatValue]]; /* 构建 styles 调用更新样式的方法 */ NSDictionary *styles = @&#123;@&quot;fontSize&quot;: [NSNumber numberWithFloat:changeFontSize]&#125;; [self _updateStylesOnComponentThread:styles resetStyles:[NSMutableArray array] isUpdateStyles:YES];&#125; 123456789101112/* 替换 WXTextComponent 的初始化方法 利用runtime机制交换方法 */SEL oriSEL = @selector(initWithRef:type:styles:attributes:events:weexInstance:);Method originalM = class_getInstanceMethod([WXTextComponent class], oriSEL);SEL exchSEL = @selector(bmText_initWithRef:type:styles:attributes:events:weexInstance:);Method exchangeM = class_getInstanceMethod([WXTextComponent class], exchSEL); BOOL addSucc = class_addMethod([WXTextComponent class], oriSEL, method_getImplementation(exchangeM), method_getTypeEncoding(exchangeM));if (addSucc) &#123; class_replaceMethod([WXTextComponent class], exchSEL, method_getImplementation(originalM), method_getTypeEncoding(originalM));&#125; else &#123; method_exchangeImplementations(originalM, exchangeM);&#125; 竞品比较 说Weex，就不得不提到Facebook的大作React Native,下边从几个角度对比一下: 类别 Weex React Native JS库 Vue.js React.js 思想 write once, run anywhere learn once, write anywhere JS引擎 Android V8，iOS JSCore iOS JSCore,Android(未知) JS开发框架 Vue.JS 组件化 数据绑定 Virtual DOM 模板就是普通的html，数据绑定使用mustache风格 样式直接使用css React.js 组件化 数据绑定 Virtual DOM JSX模板(学习使用有一定的成本) 布局 Flexbox的子集 Flexbox的子集 打包 默认打的js bundle只包含业务js代码，体积小很多，基础js库包含在Weex sdk中 只能将ReactNative基础js库和业务js一起打成一个js bundle，没有提供分包的功能，需要制作分包打包工具 跨平台 Weex可以支持Android iOS Web三个平台 支持Android iOS两个平台，需要自己扩展去支持Web，Windows和 Node-webkit的支持正在开发中 通过对比可以得出Weex的优势 轻量级的js框架 Vue 相当于 React 轻量的可不是一点半点 打包可以将基础包和业务包分开,方便缩小业务代码的容量 跨平台这块儿只能说 在Web端 比 React Native 强一些 Weex的劣势: 组件暂不支持本地图片，需指明width和height否则无法显示 不支持z-index ListView 性能 着重说下ListView的问题，从React Native的ListView的不复用,会造成内存和性能的问题,这个也是React Native一直以来最为诟病的组件，没有之一！！！ 那么我们来看一下 Weex的的 list实现: 1234567891011@implementation WXListComponent&#123; __weak UITableView * _tableView; // Only accessed on component thread NSMutableArray&lt;WXSection *&gt; *_sections; // Only accessed on main thread NSMutableArray&lt;WXSection *&gt; *_completedSections; NSUInteger _previousLoadMoreRowNumber;&#125; 我们可以看出 Weex的 WXListComponent 使用到了iOS特有的UITableView,这相比React Native的的ListView 只是 Scrollview 加了一些属性，在性能的提升上，肯定有了质的提升,但是会存在另外一个问题，我们首先看一下iOS端的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)_insertSubcomponent:(WXComponent *)subcomponent atIndex:(NSInteger)index&#123; // 子组件如果是cell if ([subcomponent isKindOfClass:[WXCellComponent class]]) &#123; ((WXCellComponent *)subcomponent).list = self; // 子组件如果是header &#125; else if ([subcomponent isKindOfClass:[WXHeaderComponent class]]) &#123; ((WXHeaderComponent *)subcomponent).list = self; // 除了上述两个，子组件只能是refresh 、loading或者fixed-component &#125; else if (![subcomponent isKindOfClass:[WXRefreshComponent class]] &amp;&amp; ![subcomponent isKindOfClass:[WXLoadingComponent class]] &amp;&amp; subcomponent-&gt;_positionType != WXPositionTypeFixed) &#123; WXLogError(@&quot;list only support cell/header/refresh/loading/fixed-component as child.&quot;); return; &#125; [super _insertSubcomponent:subcomponent atIndex:index]; // 构造section NSIndexPath *indexPath = [self indexPathForSubIndex:index]; if (_sections.count &lt;= indexPath.section) &#123; WXSection *section = [WXSection new]; if ([subcomponent isKindOfClass:[WXHeaderComponent class]]) &#123; section.header = (WXHeaderComponent*)subcomponent; &#125; //TODO: consider insert header at middle [_sections addObject:section]; NSUInteger index = [_sections indexOfObject:section]; // section的数目是有header和cell在template中出现的顺序决定的，具体可以查看函数`indexPathForSubIndex:` NSIndexSet *indexSet = [NSIndexSet indexSetWithIndex:index]; WXSection *completedSection = [section copy]; // 这里很重要，当你最终组合除了indexSet之后，调用_tableView的`insertSections`来更新tableView。 [self.weexInstance.componentManager _addUITask:^&#123; [_completedSections addObject:completedSection]; WXLogDebug(@&quot;Insert section:%ld&quot;, (unsigned long)[_completedSections indexOfObject:completedSection]); [UIView performWithoutAnimation:^&#123; [_tableView insertSections:indexSet withRowAnimation:UITableViewRowAnimationNone]; &#125;]; &#125;]; &#125;&#125; 从上述代码可以看出:list组件的子组件只能是cell、header、refresh、loading已经fixed-component,这样的规定可能让一些开发者觉得很不舒服,还有就是header组件,在目前的项目的实际开发中还存在一些Bug,部分截图如下: 我们能看的出来,最后一张图的“下午号源”的header “莫名其妙”的丢失了,类似这样的问题在Weex中 还比较常见，我们的客户端团队也在解决中大量类似的问题~ 还有我们在iOS 客户端使用UITableView的流程应该为 请求/准备 数据 reaload tableview 但是我们细看Weex的List源码 存在大量的刷新,就会出现频繁调用 reloadRowsAtIndexPaths、insertRowsAtIndexPaths、deleteRowsAtIndexPaths等类似的方法，每个子组件的出现会让tableview发生变化,目前笔者了解的情况，这是Weex机制决定的。 尚未有好的解决方案或者说解决回来会是一个很大的工程,也希望Weex官方跟进去解决这个问题。 相比这个很“致命”的问题，React Native在最新的0.43.0版本推出了 FlatList 这个组件，这个相比之前的ListView有了很大的性能提升,所以Weex组件在丰富和稳定性的道路上，显得任重而道远吧~","tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"}]},{"title":"这个世界会好吗？","date":"2016-12-31T14:17:51.000Z","path":"2016/12/31/zongjie/","text":"楔子这是最好的时代，也是最坏的时代，这是智慧的时代，也是愚蠢的时代；这是信仰的时期，也是怀疑的时期；这是光明的季节，也是黑暗的季节；这是希望之春，也是失望之冬；人们面前有着各样事物，人们面前一无所有；人们正在直登天堂，人们正在直下地狱。 忽然 忽然又是年底了，我的感觉当我20岁以后，每一年的时光都在做变加速运动，当我们为了生计一直向前向前再向前的时候，是否会在某个瞬间,平静地接上一杯白开水，跟自己好好聊聊这艰难的人生,已经蹉跎的岁月。 其实，此时此刻我应该在南京奥林匹克中心体育馆听着 逼哥的跨年，跟几万人一起喊着 “臭不要脸”，亦或者和他们一起啜泣着唱着 港岛妹妹 还有 和你在一起，而我在知道QF跟他女朋友元旦要去厦门玩，还有没有其他喜欢李志的朋友有档期，还有一个原因我不想在沉浸于那种悲伤的气氛中了，无论是 山阴路还是热河路，还有那些听着这些歌不能入眠的晚上~ 忽然觉得自己长大了许多，忽然变得自己不认识自己了，以前拒绝当房奴的我也在今年争着抢着去成为了那个自己最不想成为的样子~ 忽然觉得生死与伤病离我们更近了，这一年中很多朋友有亲人去世，每一次知道后心里都特别特别的难受，忽然又觉得人在世上好无能为力，忽然就又好难过，然后忽然又释怀了，毕竟人总是要往前看的 O(∩_∩)O哈哈~ 旅行的意义 你拥抱热情的岛屿你埋葬记忆的土耳其你流连电影里美丽的不真实的场景却说不出你爱我的原因却说不出你欣赏我哪一种表情你却说不出在什么场合我曾让你分心说不出旅行的意义 4月份离开了去哪儿，有了一个月的带薪假，出去面试定工作，自己去了一趟巴厘岛，其实我也知道巴厘岛是情侣的度假胜地，我也没有指望自己出行能遇到什么艳遇，就是想去海边吹吹风，也去一次想去很久的香港，因为我喜欢香港电影，想去寻找影片中的点点滴滴~ 旅行，会让我思考，思考这仅有短暂且不可重来的一生应该怎么样度过，源少说我一言不合就诗和远方，我说其实我们活着就是在苟且，苟且苟且着，稍微有点趣的事情可能都会变成诗和远方，柴米油盐酱醋茶或许才是这世上最美的 “诗和远方”~ 关于郑州的记忆 似是而非或是世事可畏有情有义又是有米无炊时间改变了很多也什么都没有让我再次拥抱你 郑州 2010年毕业以后，我就再也没回过郑州，五月初的时候我回了一趟郑州，去郑大工学院看了看自己的青春，虽然它很短暂，又去篮球场蹭了会球，去看了看我们以前的寝室，木门也换成了防盗门，小卖铺的阿姨变成小姑娘，有种《国产凌凌漆》中玫瑰换杜鹃的感觉，我还记得那时候特别爱写东西，基本一周一两篇的节奏，而现在我基本只有在一年结束的时候才会去试着总结些什么，其实就是觉得写点什么才能对得起这一年，而当回忆往事的时候，才对得起过往的岁月~ 董卓瑶 毛毛你是个好姑娘 你要保护好你自己你可知世上没有什么好人 你别给他们都上了毛毛你是个好姑娘 你要把持住你的欲望你可知我想像你一样纯洁 你不能比我还要放荡 今年无论是自己认识的还是朋友介绍的，也认识了几个女孩，由于种种原因没有在一起，陆陆续续的知道了她们也都有男朋友，打心眼里替她们高兴，可能我性格里有一种缺陷，就像五月天《温柔》中 “明明是想靠近，却孤单到黎明”，但无论怎样，我觉得我成长了，拿得起，放得下，看得开~ 爱的代价 还记得年少时的梦吗，像朵永远不凋零的花~在那青春悸动的年纪,那时候我们获得信息最及时，最丰富的还是电视机那一年CCTV5 有档节目叫《足球之夜》，它的片尾曲便是这首《爱的代价》。 源少的亲戚前一段去世了，通过那件事我们都有了对生命和人生的新认知。不知道谁问过2017年的梦想是什么，我说活着~活着真好 什么 叫做 爱（这样断句）父母对子女的爱是最无私的，情侣之间的爱是最自私的，朋友间的爱是夹在其中的，这边是我对于爱的定义~ 这个世界会好吗？ 妈妈，我居然爱上了她像唱歌一样就爱上了她妈妈，当你又回首一切这个世界会好吗 扯了这么多，终于回归到题目了，我觉得我要是语文老师，我的这篇文章可能不会超过30分（60分满分）~ 真的从工作开始，是一个很大的分水岭，以前真的会“为赋新词强说愁”，现在经常是“欲说还休，欲说还休，却道天凉好个秋”~ 7月份的时候我被电信诈骗了，8月份的时候手机在优步上丢了，那一段时间我一直在单曲循环这首歌《这个世界会好吗》，感谢那个最低落的时候，帮助我的朋友们，有你们真好，我一直不觉得我是多么优秀，多么牛逼的一个人，我一直觉得我很幸运，真的~ 刚来北京的时候，加入了AC联队，一呆就是六年半，记得刚来北京的时候没踢过大场，自己经常瞎跑位，是策哥和AC联的兄弟们一步步教会我怎么去踢好自己的位置，进攻与防守也更合理，每个周六和你们并肩奋战的时候是我一周最开心的时光，有你们真好~ 在去哪儿工作时运气好，获得了一些股票，房子的首付很大一部门是来自于那笔钱，感谢去哪儿，感谢携程~ 现在我在微影时代工作，我也很幸运能进入这家公司，都说”娱乐至死”,但是中国电影的发展近一两年我们看得见，也见证了公司2016年有了很大的转型和发展，感谢娱票儿，感谢春哥，感谢饼饼，让我们结识了一群有趣的小伙伴，希望在2017年与各位同仁一起再创辉煌！ 这个世界会好吗？这个问题等我爱上了”她”再告诉你们~ 2016.12.31 雾霾有小雪 记于北京","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]}]